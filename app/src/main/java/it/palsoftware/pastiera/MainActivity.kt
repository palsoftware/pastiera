package it.palsoftware.pastiera

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.view.KeyEvent
import android.view.inputmethod.InputMethodManager
import androidx.activity.ComponentActivity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.*
import androidx.compose.animation.core.tween
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.size
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.background
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.isSystemInDarkTheme
import it.palsoftware.pastiera.R
import it.palsoftware.pastiera.inputmethod.KeyboardEventTracker
import it.palsoftware.pastiera.inputmethod.NotificationHelper
import it.palsoftware.pastiera.ui.CustomTopBar
import it.palsoftware.pastiera.ui.theme.PastieraTheme
import it.palsoftware.pastiera.BuildConfig
import it.palsoftware.pastiera.update.checkForUpdate
import it.palsoftware.pastiera.update.showUpdateDialog
import it.palsoftware.pastiera.update.UpdateCheckWorker
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material.icons.filled.Keyboard
import androidx.activity.compose.BackHandler
import kotlinx.coroutines.delay

class MainActivity : ComponentActivity() {
    
    data class KeyEventInfo(
        val keyCode: Int,
        val keyCodeName: String,
        val action: String,
        val unicodeChar: Int,
        val isAltPressed: Boolean,
        val isShiftPressed: Boolean,
        val isCtrlPressed: Boolean
    )
    
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        // Notify only events that are not output keycodes generated by the service.
        // Output keycodes (DPAD, TAB, PAGE_UP, PAGE_DOWN, ESCAPE) without modifiers
        // are generated by the service and the original event with output has already been reported.
        if (event != null) {
            val isOutputKeyCode = keyCode in listOf(
                KeyEvent.KEYCODE_DPAD_UP,
                KeyEvent.KEYCODE_DPAD_DOWN,
                KeyEvent.KEYCODE_DPAD_LEFT,
                KeyEvent.KEYCODE_DPAD_RIGHT,
                KeyEvent.KEYCODE_TAB,
                KeyEvent.KEYCODE_PAGE_UP,
                KeyEvent.KEYCODE_PAGE_DOWN,
                KeyEvent.KEYCODE_ESCAPE
            )
            val hasModifiers = event.isAltPressed || event.isShiftPressed || event.isCtrlPressed
            
            // Ignora i keycode di output senza modificatori (sono generati dal servizio)
            if (!isOutputKeyCode || hasModifiers) {
                KeyboardEventTracker.notifyKeyEvent(keyCode, event, "KEY_DOWN")
            }
        }
        return super.onKeyDown(keyCode, event)
    }
    
    override fun onKeyUp(keyCode: Int, event: KeyEvent?): Boolean {
        // Notify only events that are not output keycodes generated by the service.
        if (event != null) {
            val isOutputKeyCode = keyCode in listOf(
                KeyEvent.KEYCODE_DPAD_UP,
                KeyEvent.KEYCODE_DPAD_DOWN,
                KeyEvent.KEYCODE_DPAD_LEFT,
                KeyEvent.KEYCODE_DPAD_RIGHT,
                KeyEvent.KEYCODE_TAB,
                KeyEvent.KEYCODE_PAGE_UP,
                KeyEvent.KEYCODE_PAGE_DOWN,
                KeyEvent.KEYCODE_ESCAPE
            )
            val hasModifiers = event.isAltPressed || event.isShiftPressed || event.isCtrlPressed
            
            // Ignore output keycodes without modifiers (they are generated by the service)
            if (!isOutputKeyCode || hasModifiers) {
                KeyboardEventTracker.notifyKeyEvent(keyCode, event, "KEY_UP")
            }
        }
        return super.onKeyUp(keyCode, event)
    }
    
    private fun getKeyCodeName(keyCode: Int): String {
        return when (keyCode) {
            KeyEvent.KEYCODE_Q -> "KEYCODE_Q"
            KeyEvent.KEYCODE_W -> "KEYCODE_W"
            KeyEvent.KEYCODE_E -> "KEYCODE_E"
            KeyEvent.KEYCODE_R -> "KEYCODE_R"
            KeyEvent.KEYCODE_T -> "KEYCODE_T"
            KeyEvent.KEYCODE_Y -> "KEYCODE_Y"
            KeyEvent.KEYCODE_U -> "KEYCODE_U"
            KeyEvent.KEYCODE_I -> "KEYCODE_I"
            KeyEvent.KEYCODE_O -> "KEYCODE_O"
            KeyEvent.KEYCODE_P -> "KEYCODE_P"
            KeyEvent.KEYCODE_A -> "KEYCODE_A"
            KeyEvent.KEYCODE_S -> "KEYCODE_S"
            KeyEvent.KEYCODE_D -> "KEYCODE_D"
            KeyEvent.KEYCODE_F -> "KEYCODE_F"
            KeyEvent.KEYCODE_G -> "KEYCODE_G"
            KeyEvent.KEYCODE_H -> "KEYCODE_H"
            KeyEvent.KEYCODE_J -> "KEYCODE_J"
            KeyEvent.KEYCODE_K -> "KEYCODE_K"
            KeyEvent.KEYCODE_L -> "KEYCODE_L"
            KeyEvent.KEYCODE_Z -> "KEYCODE_Z"
            KeyEvent.KEYCODE_X -> "KEYCODE_X"
            KeyEvent.KEYCODE_C -> "KEYCODE_C"
            KeyEvent.KEYCODE_V -> "KEYCODE_V"
            KeyEvent.KEYCODE_B -> "KEYCODE_B"
            KeyEvent.KEYCODE_N -> "KEYCODE_N"
            KeyEvent.KEYCODE_M -> "KEYCODE_M"
            KeyEvent.KEYCODE_SPACE -> "KEYCODE_SPACE"
            KeyEvent.KEYCODE_ENTER -> "KEYCODE_ENTER"
            KeyEvent.KEYCODE_DEL -> "KEYCODE_DEL"
            KeyEvent.KEYCODE_BACK -> "KEYCODE_BACK"
            else -> "KEYCODE_$keyCode"
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Check if tutorial has been completed
        if (!SettingsManager.isTutorialCompleted(this)) {
            val intent = Intent(this, TutorialActivity::class.java)
            startActivity(intent)
            finish()
            return
        }
        
        // Schedule periodic background update checks (every 24 hours).
        UpdateCheckWorker.schedule(applicationContext)
        
        enableEdgeToEdge()
        setContent {
            PastieraTheme {
                Box(modifier = Modifier.fillMaxSize()) {
                    Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                        KeyboardSetupScreen(
                            modifier = Modifier
                                .padding(innerPadding)
                                .fillMaxSize(),
                            activity = this@MainActivity
                        )
                    }
                    
                    // Status bar overlay - responsive to theme
                    val statusBarHeight = WindowInsets.statusBars.asPaddingValues().calculateTopPadding()
                    val isDarkTheme = isSystemInDarkTheme()
                    val overlayColor = if (isDarkTheme) {
                        // Dark theme: use black overlay
                        Color.Black.copy(alpha = 0.3f)
                    } else {
                        // Light theme: use white overlay
                        Color.White.copy(alpha = 0.2f)
                    }
                    
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(statusBarHeight)
                            .background(overlayColor)
                    )
                }
            }
        }
    }
}

@Composable
fun KeyboardSetupScreen(
    modifier: Modifier = Modifier,
    activity: MainActivity
) {
    val context = LocalContext.current
    
    var testText by remember { mutableStateOf("") }
    val lastKeyEventState = remember { mutableStateOf<KeyboardEventTracker.KeyEventInfo?>(null) }
    val lastKeyEvent by lastKeyEventState
    
    // State for IME status
    var isPastieraEnabled by remember { mutableStateOf(false) }
    var isPastieraSelected by remember { mutableStateOf(false) }
    
    // Check IME status
    LaunchedEffect(Unit) {
        checkImeStatus(context) { enabled, selected ->
            isPastieraEnabled = enabled
            isPastieraSelected = selected
        }
    }
    
    // Refresh IME status periodically and when activity resumes
    LaunchedEffect(Unit) {
        // Check status every 2 seconds when screen is visible
        while (true) {
            kotlinx.coroutines.delay(2000)
            checkImeStatus(context) { enabled, selected ->
                isPastieraEnabled = enabled
                isPastieraSelected = selected
            }
        }
    }
    
    // Request notification permission (Android 13+)
    val requestPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            android.util.Log.d("MainActivity", "Notification permission granted")
        } else {
            android.util.Log.w("MainActivity", "Notification permission denied")
        }
    }
    
    // Request notification permission when the composable is created (Android 13+ only)
    LaunchedEffect(Unit) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (!NotificationHelper.hasNotificationPermission(context)) {
                requestPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)
            }
        }
    }
    
    // Connect state to the global tracker
    LaunchedEffect(Unit) {
        KeyboardEventTracker.registerState(lastKeyEventState)
    }
    
    // Clear state when the composable is removed
    DisposableEffect(Unit) {
        onDispose {
            KeyboardEventTracker.unregisterState()
        }
    }
    
    // Automatic update check on screen open (only once, respecting dismissed releases)
    LaunchedEffect(Unit) {
        checkForUpdate(
            context = context,
            currentVersion = BuildConfig.VERSION_NAME,
            ignoreDismissedReleases = true
        ) { hasUpdate, latestVersion, downloadUrl ->
            if (hasUpdate && latestVersion != null) {
                showUpdateDialog(context, latestVersion, downloadUrl)
            }
        }
    }
    
    // Main screen
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .verticalScroll(rememberScrollState()),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Custom top bar with personalized graphics
        CustomTopBar(
            onSettingsClick = {
                val settingsIntent = Intent(context, SettingsActivity::class.java)
                context.startActivity(settingsIntent)
                (context as? Activity)?.let { activity ->
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                        activity.overrideActivityTransition(
                            Activity.OVERRIDE_TRANSITION_OPEN,
                            R.anim.slide_in_from_right,
                            0
                        )
                    } else {
                        @Suppress("DEPRECATION")
                        activity.overridePendingTransition(R.anim.slide_in_from_right, 0)
                    }
                }
            },
            modifier = Modifier.fillMaxWidth()
        )
        
        // Enable Pastiera button
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .clickable {
                    val intent = Intent(Settings.ACTION_INPUT_METHOD_SETTINGS)
                    context.startActivity(intent)
                }
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.weight(1f)
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Keyboard,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Text(
                            text = stringResource(R.string.enable_pastiera),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    if (!isPastieraEnabled) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Filled.Warning,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.error,
                                modifier = Modifier.size(20.dp)
                            )
                            Text(
                                text = stringResource(R.string.pastiera_not_enabled),
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.error
                            )
                        }
                    } else {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
        
        // Choose input method button
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .clickable {
                    val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                    imm.showInputMethodPicker()
                }
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.weight(1f)
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Keyboard,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Text(
                            text = stringResource(R.string.choose_input_method),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    if (isPastieraEnabled && !isPastieraSelected) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Filled.Warning,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.error,
                                modifier = Modifier.size(20.dp)
                            )
                            Text(
                                text = stringResource(R.string.pastiera_not_selected),
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.error
                            )
                        }
                    } else {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
        
        // Test field
        OutlinedTextField(
            value = testText,
            onValueChange = { testText = it },
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            placeholder = { Text(stringResource(R.string.test_field_placeholder)) },
            minLines = 2,
            maxLines = 5
        )
        
        // Last keyboard event (only if present)
        val event = lastKeyEvent
        if (event != null) {
            Surface(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = stringResource(R.string.last_keyboard_event_title),
                        style = MaterialTheme.typography.titleSmall,
                        fontWeight = FontWeight.Medium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "${event.keyCodeName}",
                        style = MaterialTheme.typography.bodyMedium,
                        fontFamily = FontFamily.Monospace
                    )
                    Text(
                        text = "${stringResource(R.string.event_unicode_label)}${event.unicodeChar} (${if (event.unicodeChar != 0) event.unicodeChar.toChar() else stringResource(R.string.event_not_available)})",
                        style = MaterialTheme.typography.bodyMedium,
                        fontFamily = FontFamily.Monospace
                    )
                    if (event.outputKeyCodeName != null) {
                        Text(
                            text = "${stringResource(R.string.event_output_label)}${event.outputKeyCodeName}${if (event.outputKeyCode != null) " (${event.outputKeyCode})" else ""}",
                            style = MaterialTheme.typography.bodyMedium,
                            fontFamily = FontFamily.Monospace,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                    if (event.isShiftPressed || event.isCtrlPressed || event.isAltPressed) {
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            if (event.isShiftPressed) {
                                Surface(
                                    color = MaterialTheme.colorScheme.primaryContainer,
                                    shape = MaterialTheme.shapes.small
                                ) {
                                    Text(
                                        text = stringResource(R.string.modifier_shift),
                                        style = MaterialTheme.typography.labelSmall,
                                        modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp),
                                        fontWeight = FontWeight.Medium
                                    )
                                }
                            }
                            if (event.isCtrlPressed) {
                                Surface(
                                    color = MaterialTheme.colorScheme.primaryContainer,
                                    shape = MaterialTheme.shapes.small
                                ) {
                                    Text(
                                        text = stringResource(R.string.modifier_ctrl),
                                        style = MaterialTheme.typography.labelSmall,
                                        modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp),
                                        fontWeight = FontWeight.Medium
                                    )
                                }
                            }
                            if (event.isAltPressed) {
                                Surface(
                                    color = MaterialTheme.colorScheme.primaryContainer,
                                    shape = MaterialTheme.shapes.small
                                ) {
                                    Text(
                                        text = stringResource(R.string.modifier_alt),
                                        style = MaterialTheme.typography.labelSmall,
                                        modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp),
                                        fontWeight = FontWeight.Medium
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * Checks if Pastiera IME is enabled and selected.
 * Uses InputMethodManager for Android 14+ compatibility.
 */
private fun checkImeStatus(
    context: Context,
    callback: (enabled: Boolean, selected: Boolean) -> Unit
) {
    try {
        val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        val pastieraPackageName = "it.palsoftware.pastiera"
        val pastieraImeId = "it.palsoftware.pastiera/.inputmethod.PhysicalKeyboardInputMethodService"
        
        // Check if Pastiera is enabled using InputMethodManager
        val enabledInputMethods = imm.enabledInputMethodList
        val isEnabled = enabledInputMethods.any { inputMethodInfo ->
            inputMethodInfo.packageName == pastieraPackageName ||
            inputMethodInfo.id == pastieraImeId
        }
        
        // Check if Pastiera is selected
        var isSelected = false
        if (isEnabled) {
            // Try to read DEFAULT_INPUT_METHOD
            // On Android 13 (API 33) it might still work even with targetSdk 36
            // On Android 14+ (API 34+) it will throw SecurityException
            try {
                val defaultInputMethod = android.provider.Settings.Secure.getString(
                    context.contentResolver,
                    android.provider.Settings.Secure.DEFAULT_INPUT_METHOD
                ) ?: ""
                isSelected = defaultInputMethod == pastieraImeId
            } catch (e: SecurityException) {
                // On Android 14+ (API 34+) with targetSdk 36, we can't read this setting
                // Try alternative method: check if we can get current input method info
                try {
                    // Alternative: check if our IME is in the list and try to infer selection
                    // This is not 100% reliable, but it's the best we can do
                    val currentSubtype = imm.currentInputMethodSubtype
                    if (currentSubtype != null) {
                        // If we have a subtype, check if it matches our package
                        // Note: This is a heuristic and may not be 100% accurate
                        val allInputMethods = imm.inputMethodList
                        val pastieraInputMethod = allInputMethods.find { 
                            it.packageName == pastieraPackageName || it.id == pastieraImeId 
                        }
                        // If Pastiera is the only enabled IME, assume it's selected
                        if (pastieraInputMethod != null && enabledInputMethods.size == 1) {
                            isSelected = true
                        } else {
                            // We can't reliably determine, so assume not selected to show warning
                            isSelected = false
                        }
                    } else {
                        // Can't determine, assume not selected
                        isSelected = false
                    }
                } catch (e2: Exception) {
                    // If all methods fail, assume not selected
                    isSelected = false
                }
            } catch (e: Exception) {
                // Other exceptions, assume not selected
                isSelected = false
            }
        }
        
        callback(isEnabled, isSelected)
    } catch (e: Exception) {
        android.util.Log.e("MainActivity", "Error checking IME status", e)
        callback(false, false)
    }
}
